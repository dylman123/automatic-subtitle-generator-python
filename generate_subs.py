import pandas as pd
import render
import __init__

def create_captions(df_in, word_limit=7):
    '''
    Takes a dataframe of individual words as input and applies logic
    to output a new dataframe. However instead of individual words per row,
    there will now be entire captions per row of the new pandas dataframe.
    The phrases are differentiated based on speaker identities, any pauses in the audio,
    as well as a word limit per caption. Default word_limit per caption is 7.
    '''
    columns = ["Start (secs)",
               "End (secs)",
               "Duration (secs)",
               "Captions",
               "Speaker"]
    df_out = pd.DataFrame(columns=columns)  # Create a new dataframe
    row = 0  # Row counter
    consecutive = 0  # To track how many consecutive words in a caption
    
    for idx in range(len(df_in)):
        start_s = df_in.iloc[idx,0]  # Find the current timestamp
        start_ns = df_in.iloc[idx,1]  # Find the current timestamp
        start = start_s + start_ns / 1e9  # Combine into 1 time value
        
        end_s = df_in.iloc[idx,2]  # Find the current timestamp
        end_ns = df_in.iloc[idx,3]  # Find the current timestamp
        end = end_s + end_ns / 1e9  # Combine into 1 time value
        
        prev_end_s = df_in.iloc[idx-1,2]  # Find the previous end timestamp
        prev_end_ns = df_in.iloc[idx-1,3]  # Find the previous end timestamp
        prev_end = prev_end_s + prev_end_ns / 1e9  # Combine into 1 time value
        
        word = df_in.iloc[idx,4]  # Find the current word
        tag = df_in.iloc[idx,5]  # Find the current speaker tag
        prev_tag = df_in.iloc[idx-1,5]  # Find the previous speaker tag
        
        # Set three conditions for grouping words into captions
        # 1) Compare speaker tag with previous speaker tag
        if tag == prev_tag: same_speaker = True
        else: same_speaker = False
        # 2) Check that consecutive counter is under word limit
        if consecutive < word_limit - 1: under_limit = True
        else: under_limit = False
        # 3) Check for pauses in the audio
        if start == prev_end: no_pause = True
        else: no_pause = False
        
        # If any of the above three conditions are False, create a new row.
        if same_speaker and under_limit and no_pause:
            consecutive += 1  # Increment the consecutive counter
            df_out.at[row, "Captions"] = df_out.at[row, "Captions"] + " "  # Add a space
            df_out.at[row, "Captions"] = df_out.at[row, "Captions"] + word  # Add the new word to the caption
            df_out.at[row, "End (secs)"] = end
            df_out.at[row, "Speaker"] = tag
        else: 
            consecutive = 0  # Reset the consecutive counter
            row += 1  # Move to a new row
            df_out.at[row, "Captions"] = word  # Add the new word to the next caption
            df_out.at[row, "Start (secs)"] = start
            df_out.at[row, "End (secs)"] = end
            df_out.at[row, "Speaker"] = tag
        
    # Calculate caption durations
    df_out["Duration (secs)"] = df_out["End (secs)"].subtract(df_out["Start (secs)"])

    return(df_out)

def display_captions(df):
    '''
    Displays all the captions which were generated by the speech to text process.
    This can help the user identify the speaker tags.
    Renders the pandas dataframe to the screen.
    '''

    # Window geometry
    max_width = render.root.winfo_screenwidth()
    width = 900  #  Window width is fixed
    max_height = render.root.winfo_screenheight()
    scale = 0.7  # Window is scaled to 70% of fullscreen
    height = int(max_height * scale)
    render.set_size(width, height)
    from tkinter import NW,NE,SW,LEFT  # needed to parse anchor args

    # Draw instruction
    instruction = render.static_text["display_subs"]
    render.draw_info(
        text=instruction,
        x=0.1,
        y=0, 
        font="Default 10 bold",
        anchor=NW,
        justify=LEFT)
    label_height = 50  # in pixels

    # Update dimension variables
    w = render.WIDTH
    h = render.HEIGHT

    # Draw button
    border = 10
    render.draw_button(
        text="Next",
        x=1-(2*border)/w,
        y=border/h,
        command=lambda:__init__.program_ctrl(), 
        anchor=NE)

    # Draw scrollable area
    pd.set_option('display.width', 1000)
    pd.set_option('display.max_colwidth', 1000)
    render.draw_scrollable(text=df, x=0, y=1, width=w, height=h-label_height, anchor=SW)
